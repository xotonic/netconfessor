import collections
import errno
import os
import re
import sys

from .context import *

PY3 = sys.version_info[0] == 3

if PY3:
    string_types = str,
else:
    string_types = basestring,


def print_warning(msg='', key='', ctx=None):
    """Prints msg to stderr if ctx is None or the debug or verbose flags are
    set in context ctx and key is empty or not in outputted_warnings. If key is
    not empty and not in outputted_warnings, it is added to it. If msg is empty
    'No support for type "' + key + '", defaulting to string.' is printed.

    """
    if ((not key or key not in outputted_warnings) and
            (not ctx or ctx.opts.debug or ctx.opts.verbose)):
        if msg:
            print('WARNING: ' + msg)
            if key:
                outputted_warnings.append(key)
        else:
            print_warning(('No support for type "' + key + '", defaulting ' +
                           'to string.'), key, ctx)


def write_file(d, file_name, file_content, ctx):
    """Creates the directory d if it does not yet exist and writes a file to it
    named file_name with file_content in it.

    """
    d = d.replace('.', os.sep)
    wd = os.getcwd()
    try:
        os.makedirs(d, 0o777)
    except OSError as exc:
        if exc.errno == errno.EEXIST:
            pass  # The directory already exists
        else:
            raise
    try:
        os.chdir(d)
    except OSError as exc:
        if exc.errno == errno.ENOTDIR:
            print_warning(msg=('Unable to change directory to ' + d +
                               '. Probably a non-directory file with same name as one of ' +
                               'the subdirectories already exists.'), key=d, ctx=ctx)
        else:
            raise
    finally:
        if ctx.opts.verbose:
            print('Writing file to: ' + os.getcwd() + os.sep + file_name)
        os.chdir(wd)
    with open(d + os.sep + file_name, 'w+') as f:
        if isinstance(file_content, string_types):
            f.write(file_content)
        else:
            for line in file_content:
                if line is not None:
                    f.write(line)
                    f.write('\n')
                else:
                    pass  # print('WARNING: None line will be skipped in file ' + file_name)


def get_module(stmt):
    """Returns the module to which stmt belongs to"""
    if stmt.top is not None:
        return get_module(stmt.top)
    elif stmt.keyword == 'module':
        return stmt
    else:  # stmt.keyword == 'submodule':
        belongs_to = search_one(stmt, 'belongs-to')
        for (module_name, revision) in stmt.i_ctx.modules:
            if module_name == belongs_to.arg:
                return stmt.i_ctx.modules[(module_name, revision)]


def get_parent(stmt):
    """Returns closest parent which is not a choice, case or submodule
    statement. If the parent is a submodule statement, the corresponding main
    module is returned instead.

    """
    if stmt.parent is None:
        return None
    elif stmt.parent.keyword == 'submodule':
        return get_module(stmt)
    elif stmt.parent.parent is None:
        return stmt.parent
    elif stmt.parent.keyword in ('choice', 'case'):
        return get_parent(stmt.parent)
    else:
        return stmt.parent


def get_package(stmt, ctx):
    """Returns a string representing the package name of a java class generated
    from stmt, assuming that it has been or will be generated by JNC.

    """
    sub_packages = collections.deque()
    parent = get_parent(stmt)
    while parent is not None:
        stmt = parent
        parent = get_parent(stmt)
        sub_packages.appendleft(camelize(stmt.arg))
    full_package = ctx.rootpkg.split(os.sep)
    full_package.extend(sub_packages)
    return '.'.join(full_package)


def pairwise(iterable):
    """Returns an iterator that includes the next item also"""
    iterator = iter(iterable)
    item = next(iterator)  # throws StopIteration if empty.
    for next_item in iterator:
        yield (item, next_item)
        item = next_item
    yield (item, None)


def capitalize(string):
    replace = string.upper().replace('.', '_').replace('-', '_')
    if re.match(r'\d', replace):
        replace = '_' + replace
    return replace


def capitalize_first(string):
    """Returns string with its first character capitalized (if any)"""
    return string[:1].capitalize() + string[1:]


def decapitalize_first(string):
    """Returns string with its first character decapitalized (if any)"""
    return string[:1].lower() + string[1:]


def camelize(string):
    """Converts string to lower camel case

    Removes hyphens and dots and replaces following character (if any) with
    its upper-case counterpart. Does not remove consecutive or trailing hyphens
    or dots.

    If the resulting string is reserved in Java, an underline is appended

    Returns an empty string if string argument is None. Otherwise, returns
    string decapitalized and with no consecutive upper case letters.

    """
    try:  # Fetch from cache
        return camelized_stmt_args[string]
    except KeyError:
        pass
    camelized_str = collections.deque()
    if string is not None:
        iterator = pairwise(decapitalize_first(string))
        for character, next_character in iterator:
            if next_character is None:
                camelized_str.append(character.lower())
            elif character in '-.':
                camelized_str.append(capitalize_first(next_character))
                next(iterator)
            elif (character.isupper()
                  and (next_character.isupper()
                       or not next_character.isalpha())):
                camelized_str.append(character.lower())
            else:
                camelized_str.append(character)
    res = ''.join(camelized_str)
    if res in java_reserved_words | java_literals | additional_reserved_words:
        camelized_str.append('_')
    if re.match(r'\d', res):
        camelized_str.appendleft('_')
    res = ''.join(camelized_str)
    camelized_stmt_args[string] = res  # Add to cache
    return res


def normalize(string):
    """returns capitalize_first(camelize(string)), except if camelize(string)
    begins with and/or ends with a single underline: then they are/it is
    removed and a 'J' is prepended. Mimics normalize in YangElement of JNC.

    """
    try:  # Fetch from cache
        return normalized_stmt_args[string]
    except KeyError:
        pass
    res = camelize(string)
    start = 1 if res.startswith('_') else 0
    end = -1 if res.endswith('_') else 0
    if start or end:
        res = 'J' + capitalize_first(res[start:end])
    else:
        res = capitalize_first(res)
    normalized_stmt_args[string] = res  # Add to cache
    return res


def flatten(l):
    """Returns a flattened version of iterable l

    l must not have an attribute named values unless the return value values()
    is a valid substitution of l. Same applies to all items in l.

    Example: flatten([['12', '34'], ['56', ['7']]]) = ['12', '34', '56', '7']
    """
    res = []
    while hasattr(l, 'values'):
        l = list(l.values())
    for item in l:
        try:
            assert not isinstance(item, str)
            iter(item)
        except (AssertionError, TypeError):
            res.append(item)
        else:
            res.extend(flatten(item))
    return res


def get_types(yang_type, ctx):
    """Returns jnc and primitive counterparts of yang_type, which is a type,
    typedef, leaf or leaf-list statement.

    """

    # print(yang_type.keyword + ':' + yang_type.arg)

    if yang_type.keyword in anyxml_stmts:
        string = 'io.netconfessor.YangAnyXml', 'String'
        return string

    if yang_type.keyword in leaf_stmts | {'leaf'}:
        yang_type = search_one(yang_type, 'type')
    assert yang_type.keyword in ('type', 'typedef'), 'argument is type, typedef or leaf'
    if yang_type.arg == 'leafref':
        return get_types(yang_type.parent.i_leafref.i_target_node, ctx)
    primitive = normalize(yang_type.arg)
    if yang_type.keyword == 'typedef':
        primitive = normalize(get_base_type(yang_type).arg)
    if primitive == 'JBoolean':
        primitive = 'Boolean'
    if primitive == 'JString':
        primitive = 'String'
    jnc = 'io.netconfessor.Yang' + primitive
    if yang_type.arg in ('string', 'boolean'):
        pass
    elif yang_type.arg in ('enumeration', 'binary', 'union', 'empty',
                           'instance-identifier', 'identityref'):
        primitive = 'String'
    elif yang_type.arg in ('bits',):  # uint64 handled below
        primitive = 'BigInteger'
    elif yang_type.arg == 'decimal64':
        primitive = 'BigDecimal'
    elif yang_type.arg in ('int8', 'int16', 'int32', 'int64', 'uint8',
                           'uint16', 'uint32', 'uint64'):
        integer_type = ['long', 'int', 'short', 'byte']
        if yang_type.arg[:1] == 'u':  # Unsigned
            integer_type.pop()
            integer_type.insert(0, 'BigInteger')
            jnc = 'io.netconfessor.YangUI' + yang_type.arg[2:]
        if yang_type.arg[-2:] == '64':
            primitive = integer_type[0]
        elif yang_type.arg[-2:] == '32':
            primitive = integer_type[1]
        elif yang_type.arg[-2:] == '16':
            primitive = integer_type[2]
        else:  # 8 bits
            primitive = integer_type[3]
    else:
        try:
            typedef = yang_type.i_typedef
        except AttributeError:
            if yang_type.keyword == 'typedef':
                primitive = normalize(yang_type.arg)
            else:
                pkg = get_package(yang_type, ctx)
                name = normalize(yang_type.arg)
                print_warning(key=pkg + '.' + name, ctx=ctx)
        else:
            basetype = get_base_type(typedef)
            jnc, primitive = get_types(basetype, ctx)
            if get_parent(typedef).keyword in ('module', 'submodule'):
                package = get_package(typedef, ctx)
                typedef_arg = normalize(typedef.arg)
                jnc = package + '.' + typedef_arg
    return jnc, primitive


def get_base_type(stmt):
    """Returns the built in type that stmt is derived from"""
    if stmt.keyword == 'type' and stmt.arg == 'union':
        return stmt
    type_stmt = search_one(stmt, 'type')
    if type_stmt is None:
        return stmt
    try:
        typedef = type_stmt.i_typedef
    except AttributeError:
        return type_stmt
    else:
        if typedef is not None:
            return get_base_type(typedef)
        else:
            return type_stmt


def get_import(string):
    """Returns a string representing a class that can be imported in Java.

    Does not handle Generics or Array types and is data model agnostic.

    """
    if string.startswith(('java.math', 'java.util', 'io.netconfessor')):
        return string
    elif string in ('BigInteger', 'BigDecimal'):
        return '.'.join(['java.math', string])
    elif string in java_util:
        return '.'.join(['java.util', string])
    else:
        return '.'.join(['io.netconfessor', string])


def search(stmt, keywords):
    """Utility for calling Statement.search. If stmt has an i_children
    attribute, they are searched for keywords as well.

    stmt     -- Statement to search for children in
    keywords -- A string, or a tuple, list or set of strings, to search for

    Returns a set (without duplicates) of children with matching keywords.
    If choice or case is not in keywords, substatements of choice and case
    are searched as well.

    """
    if isinstance(keywords, str):
        keywords = keywords.split()
    bypassed = ('choice', 'case')
    bypass = all(x not in keywords for x in bypassed)
    dict_ = collections.OrderedDict()

    def iterate(children, acc):
        for ch in children:
            if bypass and ch.keyword in bypassed:
                _search(ch, keywords, acc)
                continue
            try:
                key = ' '.join([ch.keyword, camelize(ch.arg)])
            except TypeError:
                if ch.arg is None:  # Extension
                    key = ' '.join(ch.keyword)
                else:
                    key = ' '.join([':'.join(ch.keyword), camelize(ch.arg)])
            if key in acc:
                continue
            for keyword in keywords:
                if ch.keyword == keyword:
                    acc[key] = ch
                    break

    def _search(stmt, keywords, acc):
        if any(x in keywords for x in ('typedef', 'import',
                                       'augment', 'include')):
            old_keywords = keywords[:]
            keywords = ['typedef', 'import', 'augment', 'include']
            iterate(stmt.substmts, acc)
            keywords = old_keywords
        try:
            iterate(stmt.i_children, acc)
        except AttributeError:
            iterate(stmt.substmts, acc)

    _search(stmt, keywords, dict_)
    return list(dict_.values())


def search_one(stmt, keyword, arg=None):
    """Utility for calling Statement.search_one, including i_children."""
    res = stmt.search_one(keyword, arg=arg)
    if res is None:
        try:
            res = stmt.search_one(keyword, arg=arg, children=stmt.i_children)
        except AttributeError:
            pass
    if res is None:
        try:
            return search(stmt, keyword)[0]
        except IndexError:
            return None
    return res


def is_config(stmt):
    """Returns True if stmt is a configuration data statement"""
    config = None
    while config is None and stmt is not None:
        if stmt.keyword == 'notification':
            return False  # stmt is not config if part of a notification tree
        config = search_one(stmt, 'config')
        stmt = get_parent(stmt)
    return config is None or config.arg == 'true'


def schema_class(class_name):
    return str(class_name) + 'Schema'


def visitor_class(class_name):
    return str(class_name) + 'Visitor'


def class_javadoc(ns, stmt):
    """ Generate javadoc for class (string without '/**' and '*/' but with * on new line) """
    description = ''
    desc_stmt = search_one(stmt, 'description')
    if desc_stmt is not None:
        description += ''.join([str(desc_stmt.arg).replace('\n', '\n * ')])
    description += ''.join(['\n * <br/>\n * Namespace: ', ns])
    return description


def jstr(string):
    return '"' + string + '"'


def yang_string_to_jstring(string):
    return string.replace('\n', '\\n')


def escape_conflicts(full_class, additional_class=None):
    pkg, _, class_name = full_class.rpartition('.')
    if class_name in java_lang:
        return full_class
    elif additional_class is not None:
        apkg, _, aclass_name = additional_class.rpartition('.')
        if aclass_name == class_name:
            return full_class
        else:
            return class_name
    else:
        return class_name